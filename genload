#!/bin/bash

# Author: Phil Fox
# Description: Create real load on an LSF cluster (requires stress-ng)

# History:
# Jan 2023    : Initial version
# May 2023    : Added print_usage function
# Jun 15 2023 : Improved the scheduling function and switched from % capacity to slots
#             : Improved the logging function, implemented none, info, debug and stdout levels
#             : Added RES_REQ=rusage[mem=xxx] to the application profiles
# Aug 3 2023  : Added checks for LIM and MBATCHD at the start of each cycle, just in case
#             : LSF goes down whilst genload is still running

# LOGLEVEL: none info debug stdout
LOGLEVEL='debug'

# Each cycle check how much workload is running and submit more workload
# if required. Then wait CYCLE seconds before doing it all again.
CYCLE=20

function get_item {

	local dbfile="$configdir/$1.db"
	#local -n array=$2		# Use 'nameref' to return array to caller
	local array

	while read -r line
	do
		element=($(echo $line | tr ':' ' '))
		if [ ${element[0]} -eq 0 ]
		then
			array+=("${element[1]}")
		fi

	done < $dbfile
	count=${#array[@]}
	index=$(echo $((1 + $RANDOM % $count)))
	echo ${array[$((index - 1))]}
}

function toggle_config {

	local dbfile="$configdir/$1.db"
	local array=($(sed -n "${2}p" $dbfile | tr ':' ' '))
	
	if [ ${array[0]} -eq 0 ]
	then
		newtext="1:${array[1]}"
	else
		newtext="0:${array[1]}"
	fi

	#echo "Newtext: $newtext"

	#sed  -e "2s/.*/${num}:${text}/" profiles.db
	#sed -e '2s/^\(.\):\(.*\)/2:\2/' profiles.db

	sed -i -e "${2}s/.*/${newtext}/" $dbfile
}

function display_config {

	local dbfile="$configdir/$1.db"
	local idx=0
	local state=""
	
	echo
	while read -r line
	do
		idx=$((idx + 1))
		local array=($(echo $line | tr ':' ' '))
		if [ ${array[0]} -eq 0 ]
		then
			state="X"
		else
			state=" "
		fi
        printf "%4d. [%s] %s\n" "$idx" "$state" "${array[1]}"

	done < "$dbfile"
}

function update_config {

	local dbfile="$configdir/$1.db"
	local count=$(cat $dbfile | wc -l)

	case $1 in

		"profiles")
			title="application profiles"
			;;
		
		"users")
			title="users"
			;;

		"slots")
			title="job slots"
			;;

		"runtimes")
			title="job run duration"
			;;

		"queues")
			title="queues"
			;;
	esac

	while true
	do
		echo -e "\nSelect $title:"
		display_config "$1"
	    	printf "\n%4s. %s\n\n" "q" "quit"
		read -r -p "Enable/disable $title [1-$count] or quit [q]? " choice
		if [ -z "$choice" ] || [ "$choice" = "q" ] || [ $choice = "Q" ]
		then
			#echo Quitting
			exit 0
		fi
		if [[ $choice =~ ^[0-9]+$ ]]
		then
			if [ $choice -ge 1 ] && [ $choice -le $count ]
			then
				toggle_config "$1" "$choice"
				continue
			fi
		fi
		echo -e "\nInvalid selection"
	done

}

function create_db {

	local dbname="$configdir/$1"
	sed 's/^/0:/' "$dbname.conf" > "$dbname.db"
}

function scan_config {

	local cfgfile="$configdir/$1.conf"

	case $1 in

		"profiles")
			runuser -l $admin -c bapp | grep gl_ | awk '{print $1}' > "$cfgfile"
			;;

		"users")
			ls /home > "$cfgfile"
			;;

		"slots")
			local maxslots=$(runuser -l $admin -c bhosts | tail -n +2 | awk '{print $4}' | paste -sd+ | bc)
			local slotcount=1
			
			rm -f "$cfgfile"
			while [ $slotcount -lt $maxslots ]
			do
				echo "$slotcount" >> "$cfgfile"
				slotcount=$((slotcount + slotcount))
			done
			echo "$maxslots" >> "$cfgfile"
			;;

		"runtimes")
			cat > "$cfgfile" <<-EOF
			1
			5
			10
			15
			30
			45
			60
			120	
			EOF
			;;

		"queues")
			runuser -l $admin -c bqueues | tail -n+2 | awk '{print $1}' > $cfgfile
			;;
	esac

	log "creating database for $1"
	create_db "$1"
}

function print_usage {

	cat <<-EOF
	Usage: genload [start|stop]
	       genload [OPTION]
	       genload SLOTS

	 Start / stop the service:
	  start, --start           start the daemon
	  stop, --stop             stop the daemon

	 Options:
	  -h, help                 print this usage information
	  -p, profile              select which application profiles to use
	  -u, user                 select which user(s) to run jobs as
	  -s, slot                 specify the size of jobs by job slot
	  -r, runtime              select the job runtime
	  -q, queue                specify which queues to submit jobs to

	 Examples:
	  To start the daemon
	  genload start

	  To view the current capacity and daemon status
	  genload

	  To load a 16 slot cluster to 50%
	  genload 8

	  To load a 32 slot cluster to 100%
	  genload 32

	  To overload a 32 slot cluster, creating pending jobs
	  genload 40

	  To change which users jobs are submitted as
	  genload -u

	  To change how many slots jobs can use
	  genload -s
	
	EOF
}

function info {
	
	if [ "$LOGLEVEL" != 'none' ]
	then
		log "$1"
	fi
}

function debug {

	if [ "$LOGLEVEL" = 'debug' ] || [ "$LOGLEVEL" = 'stdout' ]
	then
		log "$1"
	fi
}

function log {

	if [ -z "$instance" ]
	then
		suffix=''
	else
		suffix="-${instance}"
	fi

	msg="$(date) $(hostname): genload${suffix}: $1"
	echo -e "$msg" >> $logfile

	if [ "$LOGLEVEL" = "stdout" ]
	then
		echo -e "$msg"
	fi
}


#
# MAIN
#

clustername=$(lsid | grep "My cluster" | awk '{print $NF}')
if [ $? -ne 0 ]
then
	LOGLEVEL='stdout'
	info "Error: Cannot query LSF cluster"
	exit 1
fi

admin=$(grep -i ^administrators $LSF_ENVDIR/lsf.cluster.* | awk '{print $3}')
runuser -l $admin -c bhosts > /dev/null
if [ $? -ne 0 ]
then
	LOGLEVEL='stdout'
	info "Error: Unable to run commands as primary LSF administrator: $admin"
	exit 1
fi

# Allow multiple instances of genload on one host
if [ "$1" = '-c' ]
then
	config="$2"
	cmd="$3"
else
	config='default'
	cmd="$1"
fi

# Create config dir
genloaddir="$HOME/.genload"
configdir="$genloaddir/$clustername/$config"
#scriptdir="$genloaddir/scripts"
logdir="$genloaddir/$clustername/log"
pidfile="$configdir/pidfile"
capfile="$configdir/capfile"
insfile="$configdir/instance"
logfile="$logdir/genload.log"
mkdir -p $configdir $logdir

# Create configuration
items=('profiles' 'slots' 'users' 'runtimes' 'queues')
for item in "${items[@]}"
do
	#debug "creating config for $item"
	[ ! -f "$configdir/$item.conf" ] || [ ! -f "$configdir/$item.db" ] && scan_config $item
done

# Set instance number
if [ -f "$insfile" ]
then
	instance="$(cat $insfile)"
else
	inscount=$(find $genloaddir -name instance | wc -l)
	instance=$((inscount + 1))
	echo $instance > $insfile
	info "first run, setting instance id to $instance"
fi

# Set default capacity to 0 slots on first run
if [ ! -f "$capfile" ]
then
	echo 0 > "$capfile"		
	info "first run, setting capacity to 0 slots"
fi


case $cmd in

	"-h" | "--help" | "help")
		print_usage
		exit 0
		;;

	"--start" | "start")
		if [ -f "$pidfile" ]
		then
			echo "daemon is already running"
			exit 1
		fi
		$0 -c $config --daemon &
		if [ $? -eq 0 ]
		then
			echo "daemon started"
			exit 0	
		else
			echo "daemon failed to start"
			exit 1
		fi
		;;

	"--stop" | "stop")
		if [ -f "$pidfile" ]
		then
			echo "stopping daemon"
			pid=$(cat $pidfile)
			kill -9 $pid
			[ $? -eq 0 ] && rm -f "$pidfile"
			log "\e[1m$config\e[0m: daemon has stopped"
			exit 0
		else
			echo "daemon is not running"
			exit 1
		fi
		;;

	"--daemon")
		if [ -f "$pidfile" ]
		then
			echo "daemon is already running"
			exit 1
		fi
		;;

	[0-9] | [0-9][0-9] | [0-9][0-9][0-9] )
		echo $cmd > $capfile
		echo -e "\e[1m$config\e[0m"
		echo "setting load to $cmd slots"
		debug "setting load to $cmd slots"
		exit 0
		;;

	"-p" | "profile" | "profiles")
		update_config "profiles"
		;;

	"-u" | "user" | "users")
		update_config "users"
		;;

	"-s" | "slot" | "slots")
		update_config "slots"
		;;

	"-r" | "runtime" | "runtimes")
		update_config "runtimes"
		;;

	"-q" | "queue" | "queues")
		update_config "queues"
		;;

	"")
		echo -e "\e[1m$config\e[0m"
		if [ -f "$pidfile" ]
		then
			pid=$(cat $pidfile)
			echo "daemon: running with PID $pid"
		else
			echo "daemon: not running"
		fi
		echo "admin: $admin"
		echo "load: $(cat $capfile) slot(s)"
		exit 0
		;;

	*)
		echo "Unknown option"
		exit 1
		;;

esac	

# Capture PID of current process for monitor/control purposes
echo $$ > $pidfile
log "\e[1m$config\e[0m: daemon started, PID $$, instance $instance"

while true
do
	debug "checking for LIM"
	ps -ef | grep [l]im 2>&1 > /dev/null
	if [ $? -ne 0 ]
	then
		debug "LIM not running, sleeping for $CYCLE seconds"
		sleep $CYCLE
		continue
	fi

	debug "checking for MBATCHD"
	ps -ef | grep [m]batchd 2>&1 > /dev/null
	if [ $? -ne 0 ]
	then
		debug "MBATCHD not running, sleeping for $CYCLE seconds"
		sleep $CYCLE
		continue
	fi

	slotretry=5
	cap=$(cat $capfile)
	debug "requested $cap slots of workload"

	# Scan for genload workload (pending and running)
	debug "scanning for genload workload (pending and running)"
	runslots=$(runuser -l $admin -c "bjobs -uall -J gl_${instance}_* -o nreq_slot -noheader 2>&1")

	if echo "$runslots" | grep '-' > /dev/null
	then
		debug "found hypen, workload not registered yet, sleep for 1s"
		sleep 1
		continue
	fi

	if echo "$runslots" | grep "not found" > /dev/null
	then 
		debug "no workload found"
		runslots=0
	else
		runslots=$(echo "$runslots" | paste -sd+ | bc)
	fi
	debug "found $runslots slot(s) of genload workload"

	# How many slots need workload
	availslots=$((cap - runslots))
	debug "$availslots available slot(s) for new workload"
	[ $availslots -le 0 ] && slotretry=0

	while [ $slotretry -gt 0 ]
	do
		debug "$slotretry retries left"
		# Get a random slot count for the job
		slots=$(get_item "slots")
		debug "random slot count is $slots"
		debug "trying a $slots slot job"

		# Make sure the job is small enough to fit in the available slots
		if [ $slots -gt $availslots ]
		then
			slotretry=$((slotretry - 1))
			debug "job too big, trying again"
			continue
		fi

		# Get random profile / queue / user and runtime, then submit to LSF
		profile=$(get_item "profiles")
		queue=$(get_item "queues")
		user=$(get_item "users")
		runtime=$(get_item "runtimes")
		jobname="gl_${instance}_${profile:3}_${runtime}"

		debug "job name: $jobname, user: $user, queue: $queue, slots: $slots, runtime: $runtime"

		# Submit the job to LSF
		#bsubcmd="bsub -app $profile -n $slots -q $queue -We $runtime blaunch runload $runtime"
		debug "submitting job to LSF"
		bsubcmd="bsub -J $jobname -app $profile -n $slots -q $queue -We $runtime blaunch runload $runtime"
		debug "$bsubcmd"
		bsubout="$(runuser -l $user -c "$bsubcmd" 2>&1)"
		debug "$bsubout"
		#log "$bsubout"

		availslots=$((availslots - slots))
		[ $availslots -le 0 ] && slotretry=0
		debug "$availslots slot(s) left for new workload"
	done

	debug "sleeping for $CYCLE seconds until next cycle"
	sleep $CYCLE

done
